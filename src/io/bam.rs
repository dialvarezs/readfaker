//! BAM file reading and writing.

use anyhow::{Context, Result};
use noodles::bam;
use noodles::bgzf;
use noodles::sam;
use noodles::sam::alignment::RecordBuf;
use std::fs::File;
use std::path::{Path, PathBuf};

/// Reader for BAM files
pub struct BamReader;

impl BamReader {
    /// Open a BAM file and return a streaming iterator over records
    ///
    /// # Example
    /// ```no_run
    /// use readfaker::io::bam::BamReader;
    /// use std::path::Path;
    ///
    /// let reader = BamReader::from_path(Path::new("input.bam"))?;
    /// for record in reader {
    ///     let record = record?;
    ///     println!("Read: {}, length: {}",
    ///         record.name().map(|n| n.to_string()).unwrap_or_default(),
    ///         record.sequence().len());
    /// }
    /// # Ok::<(), anyhow::Error>(())
    /// ```
    pub fn from_path(path: &Path) -> Result<BamReaderIterator> {
        let mut reader = bam::io::reader::Builder::default()
            .build_from_path(path)
            .with_context(|| format!("Failed to open BAM file: {}", path.display()))?;

        let header = reader.read_header().context("Failed to read BAM header")?;

        Ok(BamReaderIterator { reader, header })
    }
}

/// Iterator over BAM records
pub struct BamReaderIterator {
    reader: bam::io::Reader<bgzf::io::Reader<File>>,
    header: sam::Header,
}

impl Iterator for BamReaderIterator {
    type Item = Result<RecordBuf>;

    fn next(&mut self) -> Option<Self::Item> {
        self.reader.records().next().map(|result| {
            result
                .map_err(|e| anyhow::Error::new(e).context("Failed to read BAM record"))
                .and_then(|record| {
                    RecordBuf::try_from_alignment_record(&self.header, &record)
                        .map_err(|e| anyhow::Error::new(e).context("Failed to parse BAM record"))
                })
        })
    }
}

/// Writer for BAM files
pub struct BamWriter {
    writer: bam::io::Writer<bgzf::io::Writer<File>>,
    header: sam::Header,
}

impl BamWriter {
    /// Creates a new BAM writer for the specified file path.
    ///
    /// Creates a minimal header for unaligned reads.
    ///
    /// # Arguments
    /// * `path` - Path to the output BAM file
    pub fn new(path: &PathBuf) -> Result<Self> {
        // Create a minimal header for unaligned reads
        let header = sam::Header::builder()
            .add_comment("Generated by ReadFaker")
            .build();

        // Use builder pattern (handles BGZF internally)
        let mut writer = bam::io::writer::Builder::default()
            .build_from_path(path)
            .with_context(|| format!("Failed to create BAM file: {}", path.display()))?;

        writer
            .write_header(&header)
            .context("Failed to write BAM header")?;

        Ok(Self { writer, header })
    }

    /// Writes a single alignment record as an unaligned BAM record.
    ///
    /// # Arguments
    /// * `name` - Read name/identifier
    /// * `sequence` - Nucleotide sequence
    /// * `quality_ascii` - Quality scores in Phred+33 ASCII encoding
    pub fn write_record(
        &mut self,
        name: &str,
        sequence: &[u8],
        quality_ascii: &[u8],
    ) -> Result<()> {
        use noodles::sam::alignment::io::Write as AlignmentWrite;

        // Convert Phred+33 ASCII to raw Phred scores (0-93) for BAM format
        let quality_phred: Vec<u8> = quality_ascii
            .iter()
            .map(|&q| q.saturating_sub(33))
            .collect();

        // Create an unaligned SAM record
        let record = RecordBuf::builder()
            .set_name(name.as_bytes())
            .set_flags(sam::alignment::record::Flags::UNMAPPED)
            .set_sequence(sequence.to_vec().into())
            .set_quality_scores(quality_phred.into())
            .build();

        self.writer
            .write_alignment_record(&self.header, &record)
            .context("Failed to write BAM record")
    }

    /// Flushes the internal buffer to ensure all data is written.
    pub fn flush(&mut self) -> Result<()> {
        use std::io::Write;
        self.writer
            .get_mut()
            .flush()
            .context("Failed to flush BAM writer")
    }

    /// Finishes the writer, properly finalizing the BAM file.
    ///
    /// This writes the BGZF EOF marker and flushes all buffered data.
    /// Should be called explicitly to ensure proper file finalization.
    pub fn finish(self) -> Result<()> {
        // Get the underlying BGZF writer and call finish to write EOF marker
        self.writer
            .into_inner()
            .finish()
            .map(|_| ())
            .map_err(|e| anyhow::anyhow!("Failed to finish BAM writer: {}", e))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_bam_write_and_read() {
        let temp_file = std::env::temp_dir().join("readfaker_test.bam");
        std::fs::remove_file(&temp_file).ok();

        // Write test records with ASCII quality scores (Phred+33)
        // 'I' = 73 (ASCII) = Phred 40
        // 'J' = 74 (ASCII) = Phred 41
        {
            let mut writer = BamWriter::new(&temp_file).unwrap();
            writer.write_record("read1", b"ACGT", b"IIII").unwrap();
            writer.write_record("read2", b"TGCA", b"JJJJ").unwrap();
            writer.finish().unwrap();
        }

        // Read back and verify
        let records: Vec<RecordBuf> = BamReader::from_path(&temp_file)
            .unwrap()
            .collect::<Result<Vec<_>>>()
            .unwrap();

        assert_eq!(records.len(), 2);
        assert_eq!(
            records[0].name().map(|n| n.to_string()),
            Some("read1".to_string())
        );
        assert_eq!(records[0].sequence().as_ref(), b"ACGT");

        // Verify quality scores are stored as raw Phred (not ASCII)
        // 'I' (ASCII 73) should be stored as raw Phred 40
        let qualities_read1: Vec<u8> = records[0].quality_scores().as_ref().to_vec();
        assert_eq!(
            qualities_read1,
            vec![40, 40, 40, 40],
            "BAM should store raw Phred scores (40), not ASCII (73)"
        );

        assert_eq!(
            records[1].name().map(|n| n.to_string()),
            Some("read2".to_string())
        );

        // 'J' (ASCII 74) should be stored as raw Phred 41
        let qualities_read2: Vec<u8> = records[1].quality_scores().as_ref().to_vec();
        assert_eq!(
            qualities_read2,
            vec![41, 41, 41, 41],
            "BAM should store raw Phred scores (41), not ASCII (74)"
        );

        std::fs::remove_file(temp_file).ok();
    }

    #[test]
    fn test_bam_eof_marker() {
        use std::io::{Read, Seek};

        let temp_file = std::env::temp_dir().join("readfaker_test_eof.bam");
        std::fs::remove_file(&temp_file).ok();

        // Write a BAM file
        {
            let mut writer = BamWriter::new(&temp_file).unwrap();
            writer.write_record("read1", b"ACGT", b"IIII").unwrap();
            writer.finish().unwrap();
        }

        // Verify BGZF EOF marker is present at the end
        let mut file = File::open(&temp_file).unwrap();
        file.seek(std::io::SeekFrom::End(-28)).unwrap();
        let mut eof_block = [0u8; 28];
        file.read_exact(&mut eof_block).unwrap();

        // BGZF EOF marker is a specific 28-byte block
        let expected_eof = [
            0x1f, 0x8b, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x06, 0x00, 0x42, 0x43,
            0x02, 0x00, 0x1b, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        assert_eq!(
            eof_block, expected_eof,
            "BAM file should end with BGZF EOF marker"
        );

        std::fs::remove_file(temp_file).ok();
    }
}
